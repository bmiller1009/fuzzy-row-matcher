/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package org.bradfordmiller.fuzzyrowmatcher

import org.apache.commons.codec.digest.DigestUtils
import org.bradfordmiller.fuzzyrowmatcher.algos.AlgoResult
import org.bradfordmiller.fuzzyrowmatcher.utils.Strings
import org.bradfordmiller.fuzzyrowmatcher.config.Config
import org.bradfordmiller.fuzzyrowmatcher.db.*
import org.bradfordmiller.simplejndiutils.JNDIUtils
import org.bradfordmiller.sqlutils.SqlUtils
import org.json.JSONObject
import org.slf4j.LoggerFactory
import java.lang.RuntimeException
import java.sql.ResultSet

class FuzzyRowMatcher(private val config: Config) {

    companion object {
        val logger = LoggerFactory.getLogger(FuzzyRowMatcher::class.java)
    }

    fun fuzzyMatch(): Boolean {

        val ds = JNDIUtils.getDataSource(config.sourceJndi.jndiName, config.sourceJndi.context).left
        val hashColumns = config.sourceJndi.hashKeys
        val sql = config.sourceJndi.sql
        val algoSet = config.algoSet
        val stringLenPct = config.strLenDeltaPct
        val algoCount = config.algoSet.size
        val aggregateResults = config.aggregateScoreResults
        val ignoreDupes = config.ignoreDupes
        val commitSize = config.dbCommitSize
        val timestamp = (System.currentTimeMillis() / 1000).toString()

        var comparisonCount = 0L
        var duplicates = 0L
        var scoreCount = 0L
        var dbPayload = mutableListOf<DbPayload>()

        config.targetJndi?.let { tj ->
          logger.info("Beginning table creation....")
          val status = SqlRunner.runScript(tj.jndiName, tj.context, timestamp)
          logger.info("Tables successfully created")
          if(!status)
              throw RuntimeException("Failed to build database tables")
        }

        logger.info("Beginning fuzzy matching process...")

        JNDIUtils.getConnection(ds).use {conn ->
            conn.prepareStatement(sql, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY)!!.use { stmt ->
                stmt.executeQuery().use { rs ->
                    var rowIndex = 1
                    var rowCount = 1L
                    val rsmd = rs.metaData
                    val rsColumns = SqlUtils.getColumnsFromRs(rsmd)
                    while(rs.next()) {
                        val currentRowData = SqlUtils.stringifyRow(rs, hashColumns)
                        val currentRowHash = DigestUtils.md5Hex(currentRowData).toUpperCase()
                        val currentRsMap = SqlUtils.getMapFromRs(rs, rsColumns)
                        val jsonRecordCurrent = JsonRecord(rowCount, JSONObject(currentRsMap).toString())
                        rowCount += 1
                        while (rs.next()) {
                            val rowData = SqlUtils.stringifyRow(rs, hashColumns)
                            val rowHash = DigestUtils.md5Hex(rowData).toUpperCase()
                            val rowRsMap = SqlUtils.getMapFromRs(rs, rsColumns)
                            val jsonRecordRow = JsonRecord(rowCount, JSONObject(rowRsMap).toString())

                            if(ignoreDupes && currentRowHash == rowHash) {
                                //Duplicate row found, skip everything else
                                duplicates += 1
                                logger.trace("Duplicate found: $currentRowData is identical to $rowData. Skipping comparison")
                                continue
                            }
                            //First check if the row qualifies based on the number of characters in each string
                            if (!Strings.checkStrLen(rowData, currentRowData, stringLenPct)) {
                                logger.trace("String $rowData with length ${rowData.length} will not be checked against ${currentRowData} with length ${currentRowData.length}")
                                continue
                            }
                            val bitVector =
                                algoSet.map { algo ->
                                    val score = algo.applyAlgo(rowData, currentRowData)
                                    AlgoResult(algo.algoType, algo.qualifyThreshold(score), score, currentRowData, rowData)
                                }
                            //Now determine if this match qualifies
                            val qualifies =
                              if(aggregateResults) {
                                  bitVector.filter { bv -> !bv.qualifies }.isEmpty()
                              } else {
                                  bitVector.filter {bv -> bv.qualifies }.isNotEmpty()
                              }
                            //Publish records to queue
                            val scoreRecord =
                                if(qualifies) {
                                    val scores = bitVector.map{bv -> bv.algoType to bv.score }.toMap()
                                    scoreCount += 1
                                    ScoreRecord(scoreCount, jsonRecordCurrent.id, jsonRecordRow.id, scores)
                                } else {
                                    null
                                }
                            dbPayload.add(DbPayload(jsonRecordCurrent, jsonRecordRow, scoreRecord))
                            comparisonCount += algoCount
                            rowCount += 1
                            if(dbPayload.size % commitSize == 0L) {
                                config.targetJndi?.let { tj ->
                                    SqlPersistor.writeRecords(dbPayload, timestamp, tj)
                                }
                            }
                        }
                        rowIndex += 1
                        logger.trace("Cursor moved to row index $rowIndex")
                        rs.absolute(rowIndex)
                    }
                    if(dbPayload.isNotEmpty()) {
                        //Publish the balance of the payload
                    }
                    logger.info("Fuzzy match is complete. $comparisonCount comparisons calculated and $scoreCount successful matches. $duplicates times duplicate values were detected.")
                }
            }
        }
        val scoreResults = dbPayload.filter {db -> db.scoreRecord != null}
        return true
    }
}