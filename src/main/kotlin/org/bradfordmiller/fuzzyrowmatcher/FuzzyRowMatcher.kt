/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package org.bradfordmiller.fuzzyrowmatcher

import org.apache.commons.codec.digest.DigestUtils
import org.bradfordmiller.fuzzyrowmatcher.algos.AlgoResult
import org.bradfordmiller.fuzzyrowmatcher.utils.Strings
import org.bradfordmiller.fuzzyrowmatcher.config.Config
import org.bradfordmiller.fuzzyrowmatcher.db.*
import org.bradfordmiller.simplejndiutils.JNDIUtils
import org.bradfordmiller.sqlutils.SqlUtils
import org.json.JSONObject
import org.slf4j.LoggerFactory
import java.lang.RuntimeException
import java.sql.ResultSet

class FuzzyRowMatcher(private val config: Config) {

    companion object {
        val logger = LoggerFactory.getLogger(FuzzyRowMatcher::class.java)
    }

    fun fuzzyMatch(): Boolean {

        val ds = JNDIUtils.getDataSource(config.sourceJndi.jndiName, config.sourceJndi.context).left
        val hashColumns = config.sourceJndi.hashKeys
        val sql = config.sourceJndi.sql
        val algoSet = config.algoSet
        val stringLenPct = config.strLenDeltaPct
        val algoCount = config.algoSet.size
        val aggregateResults = config.aggregateScoreResults
        val ignoreDupes = config.ignoreDupes
        val commitSize = config.dbCommitSize
        val offset = if(config.samplePercentage == 1) 0 else config.samplePercentage

        val timestamp = (System.currentTimeMillis() / 1000).toString()
        val sqlPersistor = SqlPersistor(algoSet.size, timestamp)
        val jsonRecords = mutableListOf<JsonRecord>()
        val scoreRecords = mutableListOf<ScoreRecord?>()

        var comparisonCount = 0L
        var duplicates = 0L
        var scoreCount = 0L

        config.targetJndi?.let { tj ->
          logger.info("Beginning table creation....")
          val status = SqlRunner.runScript(tj.jndiName, tj.context, timestamp)
          logger.info("Tables successfully created")
          if(!status)
              throw RuntimeException("Failed to build database tables")
        }

        fun loadRecords() {
            config.targetJndi?.let { tj ->
                val dbPayload = DbPayload(jsonRecords, scoreRecords)
                sqlPersistor.writeRecords(dbPayload, tj)
                dbPayload.clear()
            }
        }

        logger.info("Beginning fuzzy matching process...")

        JNDIUtils.getConnection(ds).use {conn ->
            conn.prepareStatement(sql, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY)!!.use { stmt ->
                stmt.executeQuery().use { rs ->
                    var rowIndex = 1
                    var rowCount = 1L
                    var firstPass = true
                    val rsmd = rs.metaData
                    val rsColumns = SqlUtils.getColumnsFromRs(rsmd)
                    while(rs.next()) {
                        val currentRowData = SqlUtils.stringifyRow(rs, hashColumns)
                        val currentRowHash = DigestUtils.md5Hex(currentRowData).toUpperCase()
                        val currentRsMap = SqlUtils.getMapFromRs(rs, rsColumns)
                        val jsonRecordCurrent = JsonRecord(rowCount, JSONObject(currentRsMap).toString())

                        if (firstPass)
                            jsonRecords.add(jsonRecordCurrent)

                        rowCount += 1
                        while (rs.next()) {

                            if(offset != 0) {
                                rowCount += offset
                                rs.absolute(rowCount.toInt())
                            }

                            val rowData = SqlUtils.stringifyRow(rs, hashColumns)
                            val rowHash = DigestUtils.md5Hex(rowData).toUpperCase()
                            val rowRsMap = SqlUtils.getMapFromRs(rs, rsColumns)
                            val jsonRecordRow = JsonRecord(rowCount, JSONObject(rowRsMap).toString())

                            if (firstPass)
                                jsonRecords.add(jsonRecordRow)

                            if (ignoreDupes && currentRowHash == rowHash) {
                                //Duplicate row found, skip everything else
                                duplicates += 1
                                logger.trace("Duplicate found: $currentRowData is identical to $rowData. Skipping comparison")
                                continue
                            }
                            //First check if the row qualifies based on the number of characters in each string
                            if (!Strings.checkStrLen(rowData, currentRowData, stringLenPct)) {
                                logger.trace("String $rowData with length ${rowData.length} will not be checked against ${currentRowData} with length ${currentRowData.length}")
                                continue
                            }
                            val bitVector =
                                    algoSet.map { algo ->
                                        val score = algo.applyAlgo(rowData, currentRowData)
                                        AlgoResult(algo.algoType, algo.qualifyThreshold(score), score, currentRowData, rowData)
                                    }
                            //Now determine if this match qualifies
                            val qualifies =
                                    if (aggregateResults) {
                                        bitVector.filter { bv -> !bv.qualifies }.isEmpty()
                                    } else {
                                        bitVector.filter { bv -> bv.qualifies }.isNotEmpty()
                                    }
                            //Publish records to queue
                            val scoreRecord =
                                    if (qualifies) {
                                        val scores = bitVector.map { bv -> bv.algoType to bv.score }.toMap()
                                        scoreCount += 1
                                        ScoreRecord(scoreCount, jsonRecordCurrent.id, jsonRecordRow.id, scores)
                                    } else {
                                        null
                                    }
                            scoreRecords.add(scoreRecord)
                            comparisonCount += algoCount
                            if (jsonRecords.size % commitSize == 0L) {
                                loadRecords()
                            }
                            if(offset == 0)
                                rowCount += 1
                        }
                        firstPass = false
                        rowIndex += 1
                        rowCount = rowIndex.toLong()

                        rs.absolute(rowIndex)
                    }
                    loadRecords()
                    logger.info("Fuzzy match is complete. $comparisonCount comparisons calculated and $scoreCount successful matches. $duplicates times duplicate values were detected.")
                }
            }
        }
        //val scoreResults = dbPayload.filter {db -> db.scoreRecord != null}
        return true
    }
}