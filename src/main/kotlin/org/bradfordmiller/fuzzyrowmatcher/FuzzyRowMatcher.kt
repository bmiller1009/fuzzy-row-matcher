/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package org.bradfordmiller.fuzzyrowmatcher

import org.apache.commons.codec.digest.DigestUtils
import org.bradfordmiller.fuzzyrowmatcher.algos.AlgoResult
import org.bradfordmiller.fuzzyrowmatcher.algos.Strings
import org.bradfordmiller.fuzzyrowmatcher.config.Config
import org.bradfordmiller.fuzzyrowmatcher.db.DbPayload
import org.bradfordmiller.fuzzyrowmatcher.db.JsonRecord
import org.bradfordmiller.simplejndiutils.JNDIUtils
import org.bradfordmiller.sqlutils.SqlUtils
import org.json.JSONObject
import org.slf4j.LoggerFactory
import java.sql.ResultSet

class FuzzyRowMatcher(private val config: Config) {

    companion object {
        val logger = LoggerFactory.getLogger(FuzzyRowMatcher::class.java)
    }

    fun fuzzyMatch(): Boolean {

        val ds = JNDIUtils.getDataSource(config.sourceJndi.jndiName, config.sourceJndi.context).left
        val hashColumns = config.sourceJndi.hashKeys
        val sql = config.sourceJndi.sql
        val algoSet = config.algoSet
        val stringLenPct = config.strLenDeltaPct
        val algoCount = config.algoSet.size
        val aggregateResults = config.aggregateScoreResults
        val ignoreDupes = config.ignoreDupes
        val commitSize = config.dbCommitSize

        var comparisonCount = 0L
        var matches = 0L
        var duplicates = 0L
        var scoreCount = 0L
        var dbPayload = mutableListOf<DbPayload>()

        logger.info("Beginning fuzzy matching process...")

        JNDIUtils.getConnection(ds).use {conn ->
            conn.prepareStatement(sql, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY)!!.use { stmt ->
                stmt.executeQuery().use { rs ->
                    var rowIndex = 1
                    var rowCount = 0L
                    val rsmd = rs.metaData
                    val rsColumns = SqlUtils.getColumnsFromRs(rsmd)
                    while(rs.next()) {
                        var currentRowData = SqlUtils.stringifyRow(rs, hashColumns)
                        var currentRowHash = DigestUtils.md5Hex(currentRowData).toUpperCase()
                        val currentRsMap = SqlUtils.getMapFromRs(rs, rsColumns)
                        val jsonRecordCurrent = JsonRecord(rowCount, JSONObject(currentRsMap).toString())
                        dbPayload.add(DbPayload(jsonRecordCurrent, emptyList()))
                        rowCount += 1
                        while (rs.next()) {
                            var rowData = SqlUtils.stringifyRow(rs, hashColumns)
                            var rowHash = DigestUtils.md5Hex(rowData).toUpperCase()
                            var rowRsMap = SqlUtils.getMapFromRs(rs, rsColumns)
                            val jsonRecordRow = JsonRecord(rowCount, JSONObject(rowRsMap).toString())
                            if(ignoreDupes && currentRowHash == rowHash) {
                                //Duplicate row found, skip everything else
                                duplicates += 1
                                logger.trace("Duplicate found: $currentRowData is identical to $rowData. Skipping comparison")
                                continue
                            }
                            //First check if the row qualifies based on the number of characters in each string
                            if (!Strings.checkStrLen(rowData, currentRowData, stringLenPct)) {
                                logger.trace("String $rowData with length ${rowData.length} will not be checked against ${currentRowData} with length ${currentRowData.length}")
                                continue
                            }
                            val bitVector =
                                algoSet.map { algo ->
                                    val score = algo.applyAlgo(rowData, currentRowData)
                                    AlgoResult(algo.algoType, algo.qualifyThreshold(score), score, currentRowData, rowData)
                                }
                            //Now determine if this match qualifies
                            val qualifies =
                              if(aggregateResults) {
                                  bitVector.filter { bv -> !bv.qualifies }.isEmpty()
                              } else {
                                  bitVector.filter {bv -> bv.qualifies }.isNotEmpty()
                              }
                            //Publish records to queue
                            //data class ScoreRecord(val id: Long, val currentRecordId: Long, val compareRecordId: Long, val scores: Map<AlgoType, Number>)
                            if(qualifies) {
                                bitVector.forEach{ar -> matches += 1; logger.info(ar.toString())}
                            }
                            comparisonCount += algoCount
                        }
                        rowIndex += 1
                        logger.trace("Cursor moved to row index $rowIndex")
                        rs.absolute(rowIndex)
                    }
                    logger.info("Fuzzy match is complete. $comparisonCount comparisons calculated and $matches successful matches. $duplicates times duplicate values were detected.")
                }
            }
        }
        return true
    }
}